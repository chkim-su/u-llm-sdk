"""Local TTL cache for RAGClient pre-action responses."""

import hashlib
import time
from dataclasses import dataclass
from typing import Optional

from u_llm_sdk.types import PreActionContext


@dataclass
class CacheEntry:
    """Cache entry with TTL tracking.

    Attributes:
        context: The cached PreActionContext
        expires_at: Unix timestamp when this entry expires
    """

    context: PreActionContext
    expires_at: float

    def is_expired(self) -> bool:
        """Check if this cache entry has expired."""
        return time.time() > self.expires_at


class PreActionCache:
    """Simple in-memory TTL cache for pre-action responses.

    This cache reduces latency for repeated prompts by storing PreActionContext
    objects with a time-to-live (TTL). Cache keys are generated by hashing the
    combination of prompt, provider, and model.

    Design:
        - Key: hash(prompt + provider + model)
        - Value: CacheEntry with PreActionContext and expiration time
        - Eviction: TTL-based (lazy eviction on access)
        - Thread-safety: Not required (single-threaded async context)

    Example:
        >>> cache = PreActionCache(ttl_seconds=300)
        >>> key = cache.make_key("What is RAG?", "claude", "opus-4")
        >>> cache.set(key, context)
        >>> cached = cache.get(key)  # Returns context if not expired
    """

    def __init__(self, ttl_seconds: int = 300):
        """Initialize cache with TTL.

        Args:
            ttl_seconds: Time-to-live in seconds (default: 300 = 5 min)
        """
        self._cache: dict[str, CacheEntry] = {}
        self._ttl_seconds = ttl_seconds

    def make_key(
        self,
        prompt: str,
        provider: str,
        model: Optional[str] = None,
    ) -> str:
        """Generate cache key from prompt, provider, and model.

        Args:
            prompt: User prompt
            provider: Provider name (e.g., "claude", "gemini")
            model: Model name (optional)

        Returns:
            SHA256 hash of the combined inputs
        """
        key_parts = [prompt, provider, model or ""]
        key_string = "|".join(key_parts)
        return hashlib.sha256(key_string.encode()).hexdigest()

    def get(self, key: str) -> Optional[PreActionContext]:
        """Get cached context if exists and not expired.

        Args:
            key: Cache key

        Returns:
            PreActionContext if cached and valid, None otherwise
        """
        entry = self._cache.get(key)
        if entry is None:
            return None

        if entry.is_expired():
            # Lazy eviction
            del self._cache[key]
            return None

        return entry.context

    def set(self, key: str, context: PreActionContext) -> None:
        """Store context in cache with TTL.

        Args:
            key: Cache key
            context: PreActionContext to cache
        """
        expires_at = time.time() + self._ttl_seconds
        self._cache[key] = CacheEntry(context=context, expires_at=expires_at)

    def clear(self) -> None:
        """Clear all cached entries."""
        self._cache.clear()

    def evict_expired(self) -> int:
        """Remove all expired entries from cache.

        Returns:
            Number of entries evicted
        """
        expired_keys = [
            key for key, entry in self._cache.items()
            if entry.is_expired()
        ]

        for key in expired_keys:
            del self._cache[key]

        return len(expired_keys)

    def size(self) -> int:
        """Get current cache size (number of entries)."""
        return len(self._cache)
